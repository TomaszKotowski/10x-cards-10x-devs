-- =====================================================================================
-- Migration: Create Decks and Cards Tables
-- =====================================================================================
-- Purpose: Create core tables for flashcard decks and individual cards
-- Tables: decks, cards
-- Features: Leitner system (3-box spaced repetition), duplicate detection, RLS
-- Author: Database Migration System
-- Date: 2025-10-18
-- =====================================================================================

-- =====================================================================================
-- TABLE: decks
-- =====================================================================================
-- Purpose: Store flashcard decks owned by users
-- Each user can have multiple decks with unique names (case-insensitive via citext)
-- Decks are the top-level organizational unit for flashcards

create table decks (
  -- Primary identifier
  id uuid primary key default gen_random_uuid(),
  
  -- Owner reference - links to Supabase auth.users
  -- CASCADE: When user is deleted, all their decks are deleted
  user_id uuid not null references auth.users(id) on delete cascade,
  
  -- Deck metadata
  -- citext: Case-insensitive text type ensures "Math" and "math" are treated as same
  name citext not null,
  description text,
  
  -- Timestamps in UTC
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  
  -- Constraints
  -- Ensure unique deck names per user (case-insensitive due to citext)
  constraint decks_user_name_key unique (user_id, name),
  
  -- Composite unique constraint for foreign key references from child tables
  -- This allows child tables to enforce user_id consistency via composite FK
  constraint decks_id_user_key unique (id, user_id)
);

-- Enable Row Level Security
-- All queries must pass RLS policies, even from service role (unless using bypass)
alter table decks enable row level security;

-- RLS Policy: Allow authenticated users to select their own decks
-- USING clause: Determines which rows are visible
create policy decks_owner_select on decks
  for select
  to authenticated
  using (user_id = auth.uid());

-- RLS Policy: Allow authenticated users to insert their own decks
-- WITH CHECK clause: Validates new rows before insert
create policy decks_owner_insert on decks
  for insert
  to authenticated
  with check (user_id = auth.uid());

-- RLS Policy: Allow authenticated users to update their own decks
-- USING: Determines which rows can be updated
-- WITH CHECK: Validates updated rows
create policy decks_owner_update on decks
  for update
  to authenticated
  using (user_id = auth.uid())
  with check (user_id = auth.uid());

-- RLS Policy: Allow authenticated users to delete their own decks
create policy decks_owner_delete on decks
  for delete
  to authenticated
  using (user_id = auth.uid());

-- RLS Policy: Service role has full access for administrative operations
-- Used by backend services, triggers, and admin functions
create policy decks_service_role_all on decks
  to service_role
  using (true)
  with check (true);

-- Trigger: Automatically update updated_at timestamp on row modification
create trigger decks_set_updated_at
  before update on decks
  for each row
  execute function set_current_timestamp();

-- Index: Improve lookup performance for user's decks by name
create index decks_user_name_idx on decks(user_id, name);

-- =====================================================================================
-- TABLE: cards
-- =====================================================================================
-- Purpose: Store individual flashcards with question/answer pairs
-- Implements Leitner system for spaced repetition (3-box system)
-- Supports both manual and AI-generated cards with origin tracking

create table cards (
  -- Primary identifier
  id uuid primary key default gen_random_uuid(),
  
  -- Owner reference
  -- CASCADE: When user is deleted, all their cards are deleted
  user_id uuid not null references auth.users(id) on delete cascade,
  
  -- Parent deck reference (composite FK added below)
  deck_id uuid not null,
  
  -- Card origin tracking for analytics
  -- 'manual': Created by user directly
  -- 'ai': Generated by AI and accepted by user
  origin text not null default 'manual' check (origin in ('manual', 'ai')),
  
  -- Card content
  -- CHECK ensures non-empty content after trimming whitespace
  question text not null check (char_length(trim(question)) > 0),
  answer text not null check (char_length(trim(answer)) > 0),
  
  -- Normalized question for duplicate detection
  -- GENERATED ALWAYS AS: Computed column, automatically maintained by PostgreSQL
  -- Normalization: lowercase + trim + collapse multiple spaces to single space
  -- STORED: Physically stored (not computed on read) for index performance
  question_normalized text generated always as (
    regexp_replace(lower(trim(question)), '\s+', ' ', 'g')
  ) stored,
  
  -- Leitner system state (3-box spaced repetition system)
  -- Box 1: New/difficult cards (review daily - 1 day interval)
  -- Box 2: Medium difficulty (review every 3 days)
  -- Box 3: Well-known cards (review weekly - 7 days)
  leitner_box smallint not null default 1 check (leitner_box between 1 and 3),
  
  -- Scheduling fields
  -- due_at: When card should be reviewed next
  -- last_reviewed_at: When card was last reviewed (null for never reviewed)
  due_at timestamptz not null default timezone('utc', now()),
  last_reviewed_at timestamptz,
  
  -- Timestamps
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  
  -- Constraints
  -- Prevent duplicate questions within a deck (using normalized form)
  -- This ensures "What is 2+2?" and "what is  2+2?" are treated as duplicates
  constraint cards_deck_question_key unique (deck_id, question_normalized),
  
  -- Composite unique constraint for foreign key references from child tables
  constraint cards_id_user_key unique (id, user_id),
  
  -- Composite foreign key ensures card belongs to deck owned by same user
  -- This prevents a user from creating cards in another user's deck
  -- CASCADE: When deck is deleted, all its cards are deleted
  constraint cards_deck_user_fkey 
    foreign key (deck_id, user_id) 
    references decks(id, user_id) 
    on delete cascade
);

-- Enable Row Level Security
alter table cards enable row level security;

-- RLS Policy: Allow authenticated users to select their own cards
create policy cards_owner_select on cards
  for select
  to authenticated
  using (user_id = auth.uid());

-- RLS Policy: Allow authenticated users to insert their own cards
create policy cards_owner_insert on cards
  for insert
  to authenticated
  with check (user_id = auth.uid());

-- RLS Policy: Allow authenticated users to update their own cards
create policy cards_owner_update on cards
  for update
  to authenticated
  using (user_id = auth.uid())
  with check (user_id = auth.uid());

-- RLS Policy: Allow authenticated users to delete their own cards
create policy cards_owner_delete on cards
  for delete
  to authenticated
  using (user_id = auth.uid());

-- RLS Policy: Service role has full access
create policy cards_service_role_all on cards
  to service_role
  using (true)
  with check (true);

-- Trigger: Automatically update updated_at timestamp
create trigger cards_set_updated_at
  before update on cards
  for each row
  execute function set_current_timestamp();

-- =====================================================================================
-- CARD CONTENT CHANGE HANDLING
-- =====================================================================================

-- Function: Reset card schedule when content changes
-- Purpose: When question or answer is modified, reset the card to box 1 (new/difficult)
-- Rationale: Modified cards should be re-learned from scratch to ensure mastery
-- Behavior:
--   - Resets leitner_box to 1
--   - Makes card due immediately (due_at = now)
--   - Clears last_reviewed_at timestamp
create or replace function cards_reset_schedule_on_content_change()
returns trigger as $$
begin
  -- Check if question or answer has changed
  -- IS DISTINCT FROM: NULL-safe comparison (handles null values correctly)
  if (old.question is distinct from new.question) or 
     (old.answer is distinct from new.answer) then
    -- Reset to box 1 (new/difficult cards)
    new.leitner_box = 1;
    -- Make card due immediately for review
    new.due_at = timezone('utc', now());
    -- Clear last review timestamp
    new.last_reviewed_at = null;
  end if;
  return new;
end;
$$ language plpgsql;

-- Trigger: Reset schedule when card content is modified
-- BEFORE UPDATE: Runs before the update is committed, allowing modification of NEW
create trigger cards_reset_schedule_on_content_change
  before update on cards
  for each row
  execute function cards_reset_schedule_on_content_change();

-- =====================================================================================
-- INDEXES FOR QUERY PERFORMANCE
-- =====================================================================================

-- Index: Find due cards for a specific deck (primary study session query)
-- Query: SELECT * FROM cards WHERE user_id = ? AND deck_id = ? AND due_at <= now()
-- This is the most common query when starting a study session
create index cards_user_deck_due_idx on cards(user_id, deck_id, due_at);

-- Index: Find all due cards across all decks for a user
-- Query: SELECT * FROM cards WHERE user_id = ? AND due_at <= now()
-- Used for "study all due cards" feature
create index cards_due_idx on cards(user_id, due_at);

-- Index: Analytics query - track AI adoption rate
-- Query: SELECT origin, COUNT(*) FROM cards WHERE user_id = ? GROUP BY origin
-- Used for measuring percentage of AI-generated vs manual cards
create index cards_origin_idx on cards(user_id, origin);
